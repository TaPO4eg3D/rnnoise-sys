use std::env;
use std::fs;
use std::path::PathBuf;

const RNNOISE_URL: &str =
    "https://github.com/xiph/rnnoise/releases/download/v0.2/rnnoise-0.2.tar.gz";

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let rnnoise_dir = out_dir.join("rnnoise-0.2");

    if !rnnoise_dir.exists() {
        let resp = ureq::get(RNNOISE_URL).call().expect("failed to download");
        let reader = resp.into_body().into_reader();
        let decoder = flate2::read::GzDecoder::new(reader);

        let mut archive = tar::Archive::new(decoder);
        archive.unpack(&out_dir).expect("failed to unpack");
    }

    let src_dir = rnnoise_dir.join("src");
    let include_dir = rnnoise_dir.join("include");

    // x86cpu.h includes "opus_defines.h" (from the Opus codec) when
    // OPUS_X86_MAY_HAVE_SSE2 is defined, but rnnoise ships without it.
    // Write a minimal stub so the MSVC build (which defines that macro) can
    // find the file.  The stub is harmless on other platforms.
    let opus_defines = src_dir.join("opus_defines.h");
    if !opus_defines.exists() {
        fs::write(
            &opus_defines,
            "/* Minimal stub generated by rnnoise-sys build.rs */\n\
             #ifndef OPUS_DEFINES_H\n\
             #define OPUS_DEFINES_H\n\
             #if !defined(OPUS_GNUC_PREREQ)\n\
             # if defined(__GNUC__) && defined(__GNUC_MINOR__)\n\
             #  define OPUS_GNUC_PREREQ(_maj,_min) \\\n\
                  ((__GNUC__<<16)+__GNUC_MINOR__>=((_maj)<<16)+(_min))\n\
             # else\n\
             #  define OPUS_GNUC_PREREQ(_maj,_min) 0\n\
             # endif\n\
             #endif\n\
             #endif /* OPUS_DEFINES_H */\n",
        )
        .expect("failed to write opus_defines.h stub");
    }

    let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();
    let target_env = env::var("CARGO_CFG_TARGET_ENV").unwrap_or_default();
    let is_x86 = target_arch == "x86" || target_arch == "x86_64";
    let is_msvc = target_env == "msvc";

    let mut build = cc::Build::new();
    build
        .include(&include_dir)
        .include(&src_dir)
        .define("RNNOISE_BUILD", None)
        .define("DISABLE_DEBUG_FLOAT", "1")
        .file(src_dir.join("denoise.c"))
        .file(src_dir.join("rnn.c"))
        .file(src_dir.join("pitch.c"))
        .file(src_dir.join("kiss_fft.c"))
        .file(src_dir.join("celt_lpc.c"))
        .file(src_dir.join("nnet.c"))
        .file(src_dir.join("nnet_default.c"))
        .file(src_dir.join("parse_lpcnet_weights.c"))
        .file(src_dir.join("rnnoise_data.c"))
        .file(src_dir.join("rnnoise_tables.c"));

    if is_x86 {
        build
            .define("RNN_ENABLE_X86_RTCD", "1")
            .file(src_dir.join("x86/x86_dnn_map.c"))
            .file(src_dir.join("x86/x86cpu.c"));
        if is_msvc {
            // MSVC on x64 does not predefine __SSE__ / __SSE2__ even though SSE2
            // is always available.  x86_arch_macros.h (part of the rnnoise source)
            // will define those GCC-style macros for MSVC when the corresponding
            // OPUS_X86_MAY_HAVE_* macros are present.  Without them, vec.h falls
            // through to an `#include "os_support.h"` that does not exist in the
            // rnnoise distribution tree, causing a fatal compile error.
            build
                .define("OPUS_X86_MAY_HAVE_SSE", "1")
                .define("OPUS_X86_MAY_HAVE_SSE2", "1");
        } else {
            build.define("CPU_INFO_BY_ASM", "1");
        }
    }

    build.compile("rnnoise");

    if is_x86 {
        // SSE4.1 sources need -msse4.1 on GCC/Clang.
        // On MSVC we pass OPUS_X86_MAY_HAVE_SSE4_1 so that x86_arch_macros.h
        // defines __SSE4_1__ (satisfying nnet_sse4_1.c's guard) and
        // OPUS_X86_MAY_HAVE_SSE2 so that vec.h takes the SSE2/AVX code path.
        let mut sse41 = cc::Build::new();
        sse41
            .include(&include_dir)
            .include(&src_dir)
            .define("RNNOISE_BUILD", None)
            .define("DISABLE_DEBUG_FLOAT", "1")
            .define("RNN_ENABLE_X86_RTCD", "1")
            .file(src_dir.join("x86/nnet_sse4_1.c"));
        if is_msvc {
            sse41
                .define("OPUS_X86_MAY_HAVE_SSE", "1")
                .define("OPUS_X86_MAY_HAVE_SSE2", "1")
                .define("OPUS_X86_MAY_HAVE_SSE4_1", "1");
        } else {
            sse41
                .define("CPU_INFO_BY_ASM", "1")
                .flag("-msse4.1");
        }
        sse41.compile("rnnoise_sse41");

        // AVX2 sources need -mavx -mfma -mavx2 on GCC/Clang, /arch:AVX2 on MSVC
        let mut avx2 = cc::Build::new();
        avx2.include(&include_dir)
            .include(&src_dir)
            .define("RNNOISE_BUILD", None)
            .define("DISABLE_DEBUG_FLOAT", "1")
            .define("RNN_ENABLE_X86_RTCD", "1")
            .file(src_dir.join("x86/nnet_avx2.c"));
        if !is_msvc {
            avx2.define("CPU_INFO_BY_ASM", "1")
                .flag("-mavx")
                .flag("-mfma")
                .flag("-mavx2");
        } else {
            avx2.flag("/arch:AVX2");
        }
        avx2.compile("rnnoise_avx2");
    }

    let bindings = bindgen::Builder::default()
        .header(include_dir.join("rnnoise.h").to_str().unwrap())
        .generate()
        .expect("Unable to generate bindings");

    bindings
        .write_to_file(out_dir.join("bindings.rs"))
        .expect("Couldn't write bindings");
}
